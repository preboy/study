
linux bash 学习笔记
    
    用户管理：
        adduser  useradd  userdel  usermod(修改用户帐号)

    用户组管理：
        groupadd groupmod  groupdel

    基础：    . * ^ $  \<\>  \{\}

    扩展：    ? + () 

    re(a|e|o)d    ()  与 | 结合使用。


通配：
    ？ 一个任意字符
    *  任意位的任意字符  ls -l [a-h]*.awk
    ^  代表取反
    [] 与正则中表示的一样
    {} 表示一组全集的集合。  ls -l {*.awk, 0?.perl}
    ^  
    grep 的模式，用‘ “ 括起来。
        -c 列出数量
        -n 列出行
        -i 忽略大小写
        -l 只列出文件名
        -h 不显示文件名
        -r 表示递归搜索
        -w 精确匹配单词


sed [opt] 'sed command'  inputfile
sed [opt] -f sed_file inputfile

    opt:
        -n:     do not print
        -e:     next string be consider a sed command.  eg:   sed -e ""  -e "" inputfile

    sed包含定位行与操作两部分组成：
    x
    x,y
    /patern/
    /pattern/pattern/
    /pattern/, x
    x,y! 表示不在x,y范围内的行，取反
    $ 表示最后一行
    sed -n '/.*bus'p input  表示所有包含bus的行

    i\  c\ 插入、修改行。
    s 替换文件行中的部分内容



    awk -F ':' 'awk code' inputfile
    awk -f awkscript input

    awk 'BEGIN {one=1, two=2} {print${onw+two}} ' inputfile


    
    引用符号，      意义
    ""              引用除了　＄　｀　\ 之外所以字符， 他们仍然是特殊意义。
    ''              所有的字符
    ``              解释为系统命令
    \               转义符

    $"varname"  与 $varname  可以保持变量的空格

    a = and 
    o = or 
    他们采用短路方式

    if [ ! -e $1 ]
    then
        ...
    elif
        ...
    else
        ...
    fi

    
    case variable in

    var1)
        command
        ;;
    var2)
        command
        ;;

    *)
        ;;
    esac



    for a in (1,2,3,4,5)            # or for a in 1,2,3,4     or   for a in {1..5}  or for a in {1..100..2}   or for a in $(seq 1 2 100)

    done

    for file in $(ls); do echo $file; done   # or  for file in $(*) 


    字符串长度：

    expr length "$string"   ====  $(#string)

    1> 相当于  >   >> 相当于 1>>

    cmd 2>&1 output.txt 将2 当作 1对待     == cmd &> 
    
    tee -a 可以追加的方式


    bash 支持普通数组(以0作为开始索引)，关联数组
    $array_var[*] 取整个数组内容
    echo ${array_var[*]}; echo ${array_var[@]}; 
    index = 1; echo ${array_var[$index]}
    
    打印长度：echo ${#array_var[*]}

    FreeBSD好像不支持关联数组，幸好还有CentOS
    declare -A Arr_Name
    Arr_Name = { [index1]=val1,[index2] = var2 }
    or
    Arr_Name[index] = var1
    Arr_Name[index] = var2
    
    获取的时候与普通数组不一样哦：
    echo ${!Arr_Name[*]} echo ${!Arr_Name[@]}

    script -x scriptfile  # 启动调试模式


    函数：
    function fname()
    {
    }
    or
    fname()
    {
        echo $1 $2;
        echo "$@";      当作多个分割的单词
        echo "$*";      当作当个单词   书上说用的比较少
        return 0;
    }
    
    调用：
    fname;   or   fname arg1 args2;

    cmd_output = $(COMMANDS)
    cmd_output = `commands`

    字符串操作时，最好使用[[ xxx ]]

    = 两边没有空格：  赋值
    = 两边有空格：    比较
    
    cat f1 f2 f3 > f4
    cat -s file  压缩多余的空行
    tr -s 也是类似的功能

    find / -name "preboy.txt" -exec cp {} old \; 或者执行脚本

    echo abcabcabcabc | xargs -d c 将输入分割成很多部分

    INPUT | xargs -n 2 ./cechao.sh   执行cehao.sh多次，每次2个参数

    echo "Hello Wha Who" | tr 'A-Z' 'a-z'

    cat file.txt | tr -d 'set1' 删除input中的制定字符
    tr -d -c '0-9 \n'  删除set之外的东西

    md5sum计算文件的md5码

    %.*  %%.*
    #.*  ##.*  可以分割函数名与扩展名


# 后台执行 并发执行    
(
    do command...

)&
wait            # 所有的子进程都结束了,后台进程都结束了,才返回



time -o outfile COMMAND

watch 'ls -l /' 默认每2s执行一次COMMAND,主要用于监视输出。




kill -15    or   kill -9 用于终止进入，通过发送信号
killall procname, 通过命名，终止所有进程


wall 向别人发送广播
mesg y/n 表示是否接收别人通过wall发送的消息，

head/tail -n 5 只显示5行

contrab 这个很久之前就知道了，


wget -t 5 url  尝试5次下载，如果有中断的话，


grep -O pattern file :  只输出被命中的串
grep -E : 使用正则表达式，否则使用通配符
grep -c ...  : 统计出现次数, 此处只统计行数，不统计一行出现的多次

grep -e "pattern" -e "pattern" :使用多个匹配
grep "text" . -R -n  表示搜索当前目录下所有的文件   : -n 表示计数，每一行前头写上行号




grep "main" . -r --include *.{h; cpp}
--include   
--exclude  --exclude_dir
表示包含或者排除

grep 可以输出匹配字符的前几行与后几行，以及上下几行，
grep -A 5,  grep -B 4，  grep -C 3  分别表示前5行，后4行，前后3行


cut -f 2, 3 filename 显示文件的第2，3列


cut N- 从第N个字符开始到行尾
N-M
-M

cut -c1-5 file 表示只显示file文件的第1 ~ 5行，
-c-2 前两个字符

其中:
-b 表示字节
-c 表示字符
-f 定义的段
    
cut file -c1-2, 6-9 --output-delimiter ","
表示以,分隔


sed -i 's/text/replace/g' file 表示将输出结果，写入到原文件  
也可以 '.../2g' 表示从第2个才开始
可以用[&] 来匹配被搜索到的东西，
echo this is an example | sed 's/\w\+/[&]/g' 

但是如果要匹配其中的一部分，可以用()来括起来，后面可以用\1 \2 来表示
echo seven EIGHT | sed 's/\([a=z]\+\) \([A-Z]\+\)/\2 \1/' 交换两个字符，呵呵，功能强大吧，


kill %jobnum
kill pid



###################################33

sed :
    $ :  standard for the last line.
    i\ a\ c\   insert append change pattern line.



sort:
    set filter by     -t:    split with :
    -k3n    sort as third filed.   number > alpha
    -u  remove repeat line
diff as uniq:   
    sort -u remove all repeat line
    uniq only remove near repeat line.

uniq -c : print the repeat count per line.
    -d : only show repeaat line
    -u : only show not repeat line


join:
    the two file must be sorted.
    -t:  set : as the filter sign.


cut:
    -c:按字符提取文本
    cut -c3 file,  提取文件每一行中的地3个字符
    cut -c1-5 file ,提取每一行的1~5个字符
     cut -c1,5 file 提取第1,5个字符
     -d:  指定分根符
     -f 按域来提取， f1,4,  f1-4
     
     
paste:
    paste file1 file2   吧文件1,2,粘贴到一块儿，  file2的每一行，粘贴到file1的每一行最后
    -d: 设置：为新的分隔符
    -s 横着放


split:    
    split : 将大文件，分隔成小文件
    split -2 srcfile  smallfilename  按每两行分隔一个文件
    split -b100 srcfile   按100B/每个文件 分隔
    split -C100 srcfile    同样是按照100B 分隔文件，但是更人性化，大小可能变化，考虑到行的问题，尽量保持文件的完整性
    
    
 tr:
     tr -d 0-9 file:  他的意思就是吧这个文件中所有的数字全部删除
     tr-d "[\n]" file  删除所有的回车符
      tr -s "[\n]" file  将所有重复的字符， 压缩成一个，这样可以用来吧很多空行替换成一个空行
      tr  s1  s2 file   用s2将s1中的字符替换掉
      tr "a-z" "A-Z" file  所有大写
      他也支持[:alpha:]  这一套东西
      tr -c  # -c 用于制定s1 中的补集
      
tar:      
      tar -xvf  压缩包   # 解压非gzip压缩包    
        tar -zxvf      #  解压gzip压缩包
        
        gzip file.all  # 压缩这个文件
        
        tar -zxvf file.all.gz # 解压
        
        gzip -d file.all.gz # 取消压缩，还原之后，仍是一个tar包
        

cat:
    -b  or  -n  ：显示行号
    -s :  两个连续的空行，只现实一行
    

tee:
    -a 追加到文件末尾
    
    
    :> logger  # 可以正阳清空文件内容
    
                
        
        (...)  &  圆括号内的命令，创建子shell运行，而且可以加到后台
        子shell中的变量 对父shell来说，是不可见的
        
         while :
         do
            echo "sss"
         done   
      
        trap "commands" SIGN    # 设置信号处理命令    '' "" 表示忽略这个信号
        
        
        [function] function_fname()
        {
            local local_variable;
            cmd1, cmd2,
        }
        只能返回0  /  1
        
        参数传递，与shell一样，通过$01234...
        
        
        命令类表：
        cmd1 && cmd2 && cmd3
        cmd1 || cmd2 || cmd3
        
        
        
        
################################################  另一本书了  ################################

echo -e \e[1,42m    # 设置颜色，参数为1,42

这二者的不同：        
var=value    赋值
var = value  比较

       let result=s1+s4
       let st+=2
       result=[ s1 + s4 ]
       result=`expr 100+200` 
       echo "4*0.2" | bc 


定义别名后（与exe一样），想使用非别名，只需要在前面加 \    # 如：  \ls  

脚本参数：
  $@  = "arg1" "arg2" "arg3"
  $*   = "arg1 arg2 arg3"
  
  export -f funcname  # n导出函数，这样，子进程就可以使用这个函数了
  
  
  获取就令的输出：
  
  $(ls | cat -n)
或者：
    `ls`
    
    字符串比较是，最好使用  【【 】】  这种双中括号
    
 cat -T file  # 使用^现实tab
 
 find 命令中 使用 -o 链接多个条件
 find -iregex  # 使用正则表达式匹配
find  -- maxdepth  mindepth  # 设置深度
    
    
    
    
xargs:      将标准输入的东西，转换成命令行参数u
    
    
    cal | xargs  # 将所有的'\n'转换成 ' '  真牛B    cal | xargs -n 3 是没3filed为一行分隔
    
    -d x : 表示使用x 分隔
    
    如果xargs 带参数，则表示执行
        
    # 可以这样写：    
    cat a.txt | xargs -I {} ls -a {}  #表示分开执行
    
    $[a+5] 这个是就算结果
    
    
    md5sum : 计算md5的工具
    
 
  扩展名：
    $(var%.*)    删除%右侧的通配符    # 从右向左匹配哈  
    $(var%.*)    更加贪婪
    
   $(var#*.)     删除所有的通配符     # 从左向右哈
   $(var##*.)    更加贪婪
       
   
       
comm :  # 比较两个文件（必须都经过排序了的）
comm file1 file2 # 显示3列，分别为 file1独有的，file2 独有的， 共有的行
参数： -1 -2 -3 表示删除第几列

setuid  setgid  # 以其他身份来运行程序

目录有一个粘滞位，表示：只有创建该目录的人，才有权限删除目录中的文件

# 目录堆栈
 cd -
 pushd popd 
       
   
  tree 这个需要自己安装 ，与windows中的一样，只不过功能更强大
  
  
  grep 默认使用通配符，——E 使用正则表达式
  -O ： 只打印出被匹配的单词
       
       
cut: 按照列来切割文件

   sed 可以使用&来代表被匹配项
   可以像lua那样使用() 括起来，在后面使用/1 /2 来指带
   
   组合多个表达式
   sed 'express1; express2; express3' = sed express1 | sed express2 | ...
   一般使用' 当使用"时，表示可以变量
   
   
   wath -n 5  "ls"  # 会见时输出结果，每5S更新一次
   
   
    
    ######################  tmux 使用简介 ############################3
    
    tmux new -s "session_name" -d   # 后台开启这个回话
    tmux has -t "session_name"      # 检测是否有这个回话
    tmux kill-session -t "session_name"  # 关闭这个回话，以及里面所有的程序
    tmux neww -n "session_name:window_name" "vim main.cpp"   # 在session_name下新建一个窗口，并运行shess_command
    
    ctrl + b, s # 在多个回话中选择
    ctrl + b, w # 在同一个回话的多个窗口中选择
    其他的已经够用了
    
    
    
    
    
    
    
    
    
  生成  : cscope -Rbkq
  使用 ： vim里：cscope add xxx
  
        

[gcc-]    nm ldd objdump # 查看EXE东西  可以加前缀哦




----------- About g++ -------------

gcc -E hello.c              只激活预处理,
gcc -S hello.c              只激活预处理和编译，就是指把文件编译成为汇编代码。
gcc -c hello.c              只激活预处理,编译,和汇编,也就是他只把程序做成obj文件   

ldir        增加include查找目录， 优先及最高


-include file  # 相当于在代码中的include  eg.  gcc hello.c -include /root/pianopan.h   

 -Ldir     制定库目录，否则知道系统的目录中去找
 
 -llibrary    制定编译的时候使用的库 



调试选项

     -g   只是编译器，在编译的时候，产生调试信息。   
    -gstabs   此选项以stabs格式声称调试信息,但是不包括gdb调试信息.   
    -gstabs+   此选项以stabs格式声称调试信息,并且包含仅供gdb使用的额外调试信息.   
    -ggdb    此选项将尽可能的生成gdb的可以使用的调试信息.
    -glevel 请求生成调试信息，同时用level指出需要多少信息，默认的level值是2

链接方式选项：

    -static 此选项将禁止使用动库。
    优点：程序运行不依赖于其他库
    缺点：文件比较大
    
    -shared (-G) 此选项将尽量使用动态库，为默认选项
    优点：生成文件比较小
    缺点：运行时需要系统提供动态库

-Wall 一般使用该选项，允许发出GCC能够提供的所有有用的警告   




预处理选项

    -Dmacro   相当于C语言中的#define macro   
    -Dmacro=defn   相当于C语言中的#define macro=defn   
    -Umacro   相当于C语言中的#undef macro   
    -undef   取消对任何非标准宏的定义 

    -O0   
    -O1   
    -O2   
    -O3   编译器的优化选项的4个级别，-O0表示没有优化,-O1为缺省值，-O3优化级别最高

-C   在预处理的时候,不删除注释信息,一般和-E使用,有时候分析程序，用这个很方便的


# 不好意思，下面这几个我懂了
    -M      生成文件关联的信息
    -MM     和上面的那个一样，但是它将忽略由#include造成的依赖关系。   
    -MD     和-M相同，但是输出将导入到.d的文件里面   
    -MMD    和-MM相同，但是输出将导入到.d的文件里面 






hexdump  od 他们都可以查看文件的内容

























