
umask 002  #表示所有新创建的文件，屏蔽了其他用户2(写)的权限。

fsetpos == fseek  == rewind    # 他们都是定位FILE流的函数。C标准提供。
ftell 获取当前位置，好像。
fflush  清洗 
ferror   feof clearerr  # 这些都是针对出错处理的函数。
fileno 与 fdopen 是流个filedescripter的交互

flockfile  funlockfile   ftrylockfile   # 针对文件操作的锁， 可以嵌套哦，亲

散列/聚集 io  readv  writev   也叫向量IO  相对于传统的线性IO



内存映射：
mmap  mremap   munmap
mprotect改变内存区域的权限
msync  : 同步到磁盘

子进程也会忽略父进程忽略的信号，其他的都是默认操作


sys_siglist[signo] # 这个东西，保存了信号对应的名字



char* asctime_r(const struct tm * time, char* buf);
char* ctime_t(const time_t* timemp);

time_t mktime(struct tm* tm);
struct tm * gmtime_r (const time_t *timep, struct tm *0result);






SSH 连接慢的问题
一下这两项改为No
GSSAPIAuthentication no
GSSAPIDelegateCredentials no
实在不行，把下面这一行改为no,准行
UseDNS no



.bashrc 常用配置
# edit by preboy
alias la='ls -alF'
alias cls='clear'
PS1="\[\e[1;32m\]\u@\h:\w$ \[\e[m\]"

cat 与 tac 是一个工具集


linux信号发生时：
    同步信号：一般是本进程自己发给自己的，比如硬件中断、raise等。
        他产是立即就发生的，可能大raise返回之前就调用了。
        
    异步信号：其它进程发的，==
        在CPU获得时间片时被调用，
        从内核切换到用户态时被调用。 可能过早的退出系统调用。


    
man syscalls
查看所有系统调用。

lib64/libc.so.6  直接运行就可以查看版本，


======================= linux shell =======================

""   部分引用，之间的$ ` \ 保留特殊意义。
''   全引用，  不保留任何特殊字符的意义，
``  与 $() 一样，解释为系统命令，  fe:   `ls` == $(ls)
\  转义符
$0 $1 等表示参数，但从10开始，就要用花括号了${10}

变量赋值：
variable=value 或者 ${variable=value}
echo $variable  ==  echo ${variable}

echo "${color:=1000}"  表示如果没有对color赋值的话，color就是1000
$* $@ 表示所有的参数  在双引号中有区别  "$*" = "$1 $2 $3"  "$@" = "$1" "$2" "$3"
$# 参数数量
$$ 脚本运行的进程号
$? 退出状态


variable:=value

readonly variable  ：这一句之后设置variable为只读变量，

test : 结果为真，返回0  结果为假，返回非0

for var in 1 2 4 5 6      for var in {1..6}  for var in ${seq 1 2 100}
注意花括号


============ about vim:
w b 他们会把标点符号当作一个word, 
W B 则不会把标点当作一个WORD

表示在一行搜索之后，继续做同样的操作  ,（方向相反） ;（方向相同）
. 表示在重复上一次的操作，比如：删除一行，
`` 把光标返回到上次G的位置或者？/的位置。





在同一行上多条命令之后用;隔开
ls -l ; who; date


通配符：

* 任意字符串
？任意一个字符
^ 取反
[]  与 正则一样
{}  表示集合：   ls -l {[a-h].awk, 0?.pem}

[a-h]*.[^awk]* 列出以a-h开头，不以awk结尾巴的



在sed中$表示最后一行
sed -n '$p' input

ls -l | sed '/cpp/czcg' 改变一行
ls -l | sed '/cpp/, out/s/game/preboy/g'   可以是pg
不带g，则具替换每一行第一次出现的位置，否则全部
sed 's/abc/def/g' 可以不指定范围
sed 'y/12345/ABCDE'  input  变化，tr也有这个功能
可以将多个命令写在一个{}里面，与多个-e参数功能一样哟，  多个之间用;隔开
sed '/partern/{n; s/1/2/g; }'  input n 表示处理下一行，
用;隔开的命令也行 
sed 's/1/2; s/3/4; ' input



${var:-333}   如果var不存在，则返回333,否则返回var
${var:=333}   如果var不存在，则返回333，并把333赋值给var,   否则返回var
${var:?333}   如果var不存在，则退出脚本并错误输出333,   否则返回var
${var?333}
${var:+333}   如果var不存在，则返回空  ,  否则返回333  与上面相反

$((exp))  符号C语言规范的表达式




()  在子shell中执行，结果不影响当前shell  比如变量修改

{} 在当前shell中执行，影响当前shell      比如变量修改





################## 字符串相关的操作：################## 

${#string}
expr length "$string" 
    求长度

expr match $string $substring
    若匹配不到，返回0，否则返回匹配到的长度
    fe: expr match "hello"  "hel"  返回3，   expr match "hello" ".*l"


${string:startpos}
${string:startpos:length_pos}
    从左开始计数，取子字符串

${string: -startpos}
${string: -(startpos)}
    从右开始计数，取子字符串

expr substr $string $postion $length
    这种方法也行，但是，索引是1开始


expr match $string '\($substring\)'
expr $string  : '\($substring\)'
    使用正则表达式匹配，从左开始

expr match $string '.*\($substring\)'
expr $string  : '.*\($substring\)'
    使用正则表达式匹配，从右开始


删除子串：
${var%pattern}    右短
${var%%pattern}   右长
${var#pattern}    左短
${var##pattern}   左长


替换：
${string/find/replace}      仅替换一次
${string//find/replace}     替换所有

${string/#find/replace}     替换开头处的字符串
${string/%find/replace}     替换结尾处的字符串    
    string=abcdef
    ${string/#a*c/111}      111def
    ${string/#de*/111}      abc111


变量的间接引用
b=100
a=b
eval tmp=\$$a 或者 tmp=${!a} 


expr 支持 | &  < > ~!  + - * / 等数学运算符
但在是expr 中若出现元字符，应当括起来，比如：  expr 100 \* 23


bc 支持浮点数运算，他是内建的计算器


cat:
    -b 编号，空不行编号
    -n 所有行编号
    -E 每一行结尾加$
    -s 去掉重复的空行


eval 与直接运行命令一样的效果，他的优势是：如果命令中包含特殊的字符，


冒号的用法：
1)
while :  # 冒号可以表示永真
do
    ...
done

2)
:>logg    清空文件



()& 在后台运行子进程
wait 等待所有字进程，因为没有默认参数


在函数内使用 let "a=100" 此时，a会变成全局变量，如果想要使得a变成局部变量，需要在之前使用 local a 声明


命令列表
c1 && c2 && c3 ..
依次执行，直到某个返回FALSE为止

c1 || c2 || c3 


数组
city[n]=value
n可以是数字不需要连续，也可以是任意字符
city[zhang]=chaoguo

    另一种方法：
    city=(v1 v2 v3 v4)     这种方式默认数字索引
    city={[2]=v2 [10]=v3   ... }
    这种情况，如果未指定索引，则自动取前一个索引并加上1


"$@"  "$*"
 用引号括起来的时候，
    @表示分开了的，
    *表示一坨，锅巴饼
    没有括，好像都一个样
这一条对于数组同样适用，
"${city[@]}"    分行打印
"${city[*]}"    打印在同一行


数组也可以取子数组、抽取、替换 与字符串差不多

${a[*]:1:3}  取第一个，到 第三个
${a[*]:0}    取第0个到默认(最后)

${a[*]#M*a}   将带有M*a的字串做处理，删除匹配的子串，但不是删除整个串哦， 最短删除   (不要写成#/哦，我犯过错)
${a[*]##M*a}  将带有M*a的字串做处理，删除匹配的子串，但不是删除整个串哦， 最长删除

${a[*]/M*a/replacement}     替换         一样的道理
${a[*]//M*a/replacement}    替换 最长    




let 中不需要使用$符号

[] 与let一个样



错误，输出，都重定向

2 > &1 

&>  



数组长度

${#a[@]}





declare -A a

数组索引

${!a[@]}





$\command  这样使用之后，不忽略了alias，而是直接使用命令





以调试方式

bash -x script.sh



文件权限制  w r x

执行位特殊权限：

    拥有者   setuid

    同组     setgid 

    粘滞位: 目录还有一个权限，在其它位的x, 表示只有目录的创建者才有限制删除文件。tT  



    chmod chown  ... -R 以递归执行下去





linux文件系统第二属性

lsattr chattr 





touch的作用：

    touch file 用于创建文件

    touch -a file 修改文件访问时间 

    touch -m file 修改文件内容更改时间

    touch -d "timeformat" ... 还可以指定其它时间



dd if=/dev/zero of=zcg.data bs=1M count=2

dd if=/dev/cdrom of=zcg.iso  创建ISO文件





seq 20 | head -n 9   打印文件前9行

seq 20 | head -n -9  打印文件除去最后9行的所有行

seq 20 | tail -n 4   打印最后4行

seq 20 | tail -n +4  打印除去最开始4行之外所有的行



sed 's/\w+/[&]/g' input   & 表示之前匹配到的



生成序列
{1..50}  {a..z}  {A..Z}

字符串比较，最好使用[[  ]]



sudo find . \( -name "*.ini" -o -name "*.conf" \)
-regex "" 使用正则表达式

find . ! -name "*.txt" -print  否定形式

unix文件有三个时间：但是无创建时间
访问时间
修改时间
变化时间  文件元数据（权限）修改时间按
stat filename 查看文件的各个时间

find . -type f -name "*.txt" -print0 | xargs -0 wc -l 
这条命令，-print0  xars -0 使用都是null结束符

这种情况很有可能
xargs -I {}  s.sh -p {} -i    # -I 用于命名，然后指定使用地方

可以将输出导出给子shell，这是一个好方法
cat file.txt | ( while read arg; do eho $arg; done)
cat file.txt | xargs 



$[1+3] 执行算术运算
$(命令)


md5sum file1 计算校验和


rename 是一款改名工具，功能很强大哦
rename 's/ /_/g' *.txt   把文件名中所有的空格，替换成_
rename 'y/[a-z]/[A-Z]' *.txt


